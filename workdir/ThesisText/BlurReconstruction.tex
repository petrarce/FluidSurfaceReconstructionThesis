\chapter{SDF blur filter}
During the reconstruction of the surface all methods in one form or another (depending on the level set computation approach) are using particle displacement information. In the SPH based fluid simulation frameworks fluid particle displacement usually are formed irregularly, thus small insufficient gaps or buimbs can be formed during the surface reconstruction phase, which are usually treated as undesirable low-frequency noise. The comparison of the surface reconstruction based on a regular and irregular displacement of the particles is in Figure \ref{fig:rec_vs_displacement}.
\begin{figure}[H]
	\begin{center}
		\begin{subfigure}[b]{0.6\textwidth}
			\includegraphics[width=\textwidth]{figures/FlatSurfaceWsParticleDisplacement.png}
			\caption{Regularly displaced particles}
		\end{subfigure}
		\begin{subfigure}[b]{0.6\textwidth}
			\includegraphics[width=\textwidth]{figures/NonFlatSurfaceWsParticleDisplacement.png}
			\caption{Irregularly displaced particles}
		\end{subfigure}
	\end{center}
	\caption{displacement of particles vs surface quality comparison}
	\label{fig:rec_vs_displacement}
\end{figure}
The main goal of this thesis is to develop a method, which will smooth out a high frequency bumps on flat surface areas, preserving the surface features. The goal of this thesis is also to develop such a method, that will be computationally plausable.\\
The first idea, that was applied to achieve stated requirements is simple blurring technique, which is extensively used in computer graphics, such as Gaussian Blur, Median blur, Bilateral blur or other image filtering techniques. In this chapter Blur-based method will be proposed. 
\section{Algorithm description}
Blur method was incorporated into the research framework according to the class hierarchy in Figure \ref{fig:class-diagam}. According to the class diagram, the method inherits the underlying base method (in our case its Density-Based, Zhu and Bridson, or Solenthaler methods), on top of which the computed level set is blurred.  Algorithm \ref{alg:blur_alg} shows the pseudo-code for \emph{updateLevelSet()}.
\begin{algorithm}[H]
	\scriptsize
	\begin{algorithmic}
		\State $levelSet \gets  BaseClass::initialLevelSet$
		\For{$i \in [0, blurIterations]$}
			\State blurLevelSet(levelSet);
		\EndFor
	\end{algorithmic}
	\caption{$updateLevelSet()$ for level set blurring method}
	\label{alg:blur_alg}
\end{algorithm}
According to Algorithm \ref{alg:blur_alg} blurring of the SDF could be performed arbitrary number of times. The influence of number of iterations will be explained in further section.

The \emph{blurLevelSet()} pseudo-code is explained in Algorithm \ref{alg:blur_level_set}
\begin{algorithm}[H]
	\scriptsize
	\begin{algorithmic}
		\ForAll{$vtx \in MC\_CellDomain$}
			\State $neighbors \gets getNeighbourVertices(vtx);$
			\State $blurredLevelSetValue \gets 0$
			\ForAll{$nbVtx \in neighbors$}
				\State $blurredLevelSetValue\gets blurredLevelSetValue + levelSet[neighborVertex]$
			\EndFor
			\State $blurredLevelSetValue\gets\dfrac{blurredLevelSetValue}{sizeof(neighbors)}$
			\State $sf\gets computeSmoothingFactor()$
			\State $blurredLevelSet[vtx]\gets levecSet[vtx] * (1 - sf) + sf * blurredLevelSetValue;$
		\EndFor
	\end{algorithmic}
	\caption{$updateLevelSet()$ for level set blurring method}
	\label{alg:blur_level_set}
\end{algorithm}
The final blurred level set value in Algorythm \ref{alg:blur_level_set} is a wighted sum between the computed level set value and initial level set value.
\subsection{Smoothing factor}
The smoothing factor is a value that determines how much new, blurred SDF value of MC grid vertex will contain its initial SDF value (weighted sum of blurred level set value and initial level set value). As described in \ref{alg:blur_level_set} level set value is updated according to the Equation \ref{eq:level_set_value}.
\begin{equation}
newLS = oldLS \cdot (1 - sf) + blurLS \cdot sf \label{eq:level_set_value}
\end{equation}
In Equation \ref{eq:level_set_value} $sf$ is a smoothing factor or a weight. The smoothing factor itself is calculated according to equation \ref{eq:smooth_factor}.
\begin{equation}
	sf_{vtx} = 1 - (1 - min(1, \dfrac{bsf \cdot fp_{vtx}}{maxFp})^2)^{10} \label{eq:smooth_factor}
\end{equation}
where:
\begin{conditions}
	vtx & vertex for which the smoothing factor is computed\\
	fp_{vtx} & number of neighbor fluid particles within support radius from vtx\\
	maxFp & maximum possible fluid particles that can be in the neighborhood of the vertex \\
	bsf & base support factor (use defined)
\end{conditions}
The smoothing factor formula was designed such that it should be maximal for MC grid vertices that contains full fluid particles set and minimum where number of fluid particles limits to zero (see Figure \ref{fig:sf_function_graph}).
\begin{figure}[H]
	\begin{center}
			\includegraphics[width=0.5\textwidth]{figures/sf_function_graph.png}		
	\end{center}
	\caption{Graphic of function, representing equation \ref{eq:smooth_factor}. Taking into account that $min(1, \dfrac{bsf \cdot fp_{vtx}}{maxFp}) \in [0,1]$ the function converges from 0 to 1 in the interval $x \in [0, 0.5]$ and limits to 1 for the area $x\in [0.5, 1]$}
	\label{fig:sf_function_graph}
\end{figure}

The motivation to apply such a smoothing factor comes from the problem of the blurring algorithm. If we apply the blur algorithm uniformly into all MC domain, the blur will smooth out the features in thin areas and the areas with a small set of particles (droplets or splashes). Figure \ref{fig:smoothing_factor_influence} shows the problem of application of the blur algorithm w.o. application of smoothing factor.

\begin{figure}[H]
	\begin{center}
		\begin{subfigure}[b]{0.7\textwidth}
			\includegraphics[width=\textwidth]{figures/BlurSmoothingFactorOriginal.png}
			\caption{Original reconstruction using Muller et. al. method}
		\end{subfigure}
		\begin{subfigure}[b]{0.7\textwidth}
			\includegraphics[width=\textwidth]{figures/BlurSmoothingFactor0.5.png}
			\caption{Blurred Muller et. al. with application of the smoothing factor}
		\end{subfigure}
		\begin{subfigure}[b]{0.7\textwidth}
			\includegraphics[width=\textwidth]{figures/BlurSmoothingFactorNonepng.png}
			\caption{Blurred Muller et. al. without smoothing factor}
		\end{subfigure}

	\end{center}
	\caption{Results of the reconstructed surface depending on the smoothing factor application}
	\label{fig:smoothing_factor_influence}
\end{figure}


The idea of blurring using a smoothing factor is to blur the level set as much as possible in the areas where the surface of the fluid is flat and to apply less blur in areas, where a set of MC cells lacks fluid particles. Suppose the general case in Figure \ref{fig:sf_example}. In the figure red, yellow and orange grid vertices contain a full, half and quarter set of particles respectively. Level set values of the grid points are supposed to be blurred as much as possible near the flat fluid surface areas, but left unchanged in areas with small set of particles.
\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.5\textwidth]{figures/SmoothingFactorPictureExplenation.png}		
		\caption{Green circles are fluid particles, red - MC cells with full set of fluid particles in the neighborhood, yellow -  MC cells with half set of fluid particles in the neighborhood, orange - MC cells with quarter set of fluid particles in the neighborhood, blue - MC cells with no fluid particles in the neighborhood}
		\label{fig:sf_example}
	\end{center}
\end{figure}
Applying blur to the level set vertices that are inside the fluid (and all its neighbor cells are also inside the fluid) will not change the level set value too much as soon all vertices that has full set of fluid particles in the neighborhood will have similar level set values.\\
For the MC vertices that are near the corners the 75\% of the neighbor vertices are outside the fluid. In this case blur iteration will bias the vertex outside the fluid, thus the fluid will shrink. This is also relevant for the thin areas and splashes.\\
At the figure \ref{fig:blur_w_o_sf} the effect of surface shrinkage of applying blur in the thin area and in the corners w.r.t. the initial reconstruction method can be observed. The flat surface is smoothed out, but at the same time surface sharpness at the thin and splash areas is degraded, some small features/droplets are lost.
\begin{figure}[H]
	\begin{center}
		\begin{subfigure}[b]{\textwidth}
			\includegraphics[width=\textwidth]{figures/DenvityBlurredSplashArea.png}
			\caption{Muller et. al.}
			\label{fig:denc_rec}
		\end{subfigure}
		\begin{subfigure}[b]{\textwidth}
			\includegraphics[width=\textwidth]{figures/DenvityBasedSplashArea.png}
			\caption{Blurred Muller et. al.}
			\label{fig:blur_w_o_sf}
		\end{subfigure}
	\end{center}
	\caption{Comparison of original reconstruction method and blurred reconstruction without application of smoothing factor}
	\label{fig:blur_thin_area}
\end{figure}
In the other hand applying blur on level set with smoothing factor smooths out the flat surface areas bumps, but preserves small feature areas (see Figure \ref{fig:blur_thin_area_with_sf}).
\begin{figure}[H]
        \begin{subfigure}[b]{0.5\textwidth}
				\includegraphics[width=\textwidth]{figures/DenvityBasedSplashArea2.png}
				\caption{Blurred Muller et. al.}
				\label{fig:blur_with_sf}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/DenvityBlurredSplashArea2.png}
               \caption{Muller et. al.}
               \label{fig:db_rec}
        \end{subfigure}
       \caption{Comparison of original reconstruction method and blurred reconstruction with application of smoothing factor}
       \label{fig:blur_thin_area_with_sf}
 \end{figure}
\subsection{Blur kernel size and offset}
The kernel size and kernel offset concept is widely used in a computer graphics blur algorithms. It is a commonly used effect in graphics software, typically to reduce image noise and resolve aliasing problems. The visual effect of this blurring technique is a smooth blur resembling that of viewing the image through a translucent screen.\\
The most popular blur technique applied in computer graphics is a Gaussian blur. Mathematically, applying a Gaussian blur to an image is the same as convolving the image with a Gaussian function. This is also known as a two-dimensional Weierstrass transform.\\
Each pixel in the image gets multiplied by the Gaussian kernel. This is done by placing the center pixel of the kernel on the image pixel and multiplying the values in the original image with the pixels in the kernel that overlap. The values resulting from these multiplications are added up and that result is used for the value at the destination pixel.\\
The kernel could be of an arbitrary size, e.g. uniform box kernel with kernel size 1:\\
$\begin{pmatrix}
1 & 1 & 1\\
1 & 1 & 1\\
1 & 1 & 1
\end{pmatrix}$\\kernel size 2:\\
$\begin{pmatrix}
1 & 1 & 1 & 1 & 1\\
1 & 1 & 1 & 1 & 1\\
1 & 1 & 1 & 1 & 1\\
1 & 1 & 1 & 1 & 1\\
1 & 1 & 1 & 1 & 1
\end{pmatrix}$\\ This could be easely extended to a 3D case, which used in this work.\\
The kernel offset, can be expressed as a smallest amount of steps over the neighborhood that should be performed to reach next sample, which will be used in blurring procedure. E.g. next matrix describes a kernel with kernel size 1 and kernel offset 2: \\
$
\begin{pmatrix}
	1 & 0 & 1 & 0 & 1\\
	0 & 0 & 0 & 0 & 0\\
	1 & 0 & 1 & 0 & 1\\
	0 & 0 & 0 & 0 & 0\\
	1 & 0 & 1 & 0 & 1
\end{pmatrix}
$.\\
Both parameter influences a quality of a surface reconstruction. However, kernel size also defines the runtime complexity of the algorithm, as soon as kernel performance of the blur stage over the SDF depends cubically on the kernel size. The total complexity of the blur stage can be expressed as $O(n\cdot k^3)$, where n is a number of MC grid vertices $k$ is a kernel size. On the other hand kernel offset doesn't influences the performance of the SDF blurring stage, as soon as according to the Algorithm \ref{alg:blur_nbs_search} it doesn't influences on the number of samples that will be picked for blurring.\\
However expansion of the kernel size/offset has its limitation on the surface quality e.g. inappropriately large kernel offset can smooth out a sharp features or even bringing artifacts to the reconstructed surface. Figure \ref{fig:ksko} shows resulting surface with different evaluation of a kernel size and kernel offset.\\
\begin{figure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/DBBlur_ks-0_ko-0.png}
               \caption{Original reconstruction}
               \label{fig:kskdOrig}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/DBBlur_ks-1_ko-1.png}
               \caption{kernel size 1, kernel offset 1}
               \label{fig:ks1ko1}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/DBBlur_ks-1_ko-2.png}
               \caption{kernel size 1, kernel offset 2}
               \label{fig:ks1ko2}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/DBBlur_ks-1_ko-4.png}
               \caption{kernel size 1, kernel offset 4}
               \label{fig:ks1ko4}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/DBBlur_ks-2_ko-1.png}
               \caption{kernel size 2, kernel offset 1}
               \label{fig:ks2ko1}
        \end{subfigure}        
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/DBBlur_ks-4_ko-1.png}
               \caption{kernel size 4, kernel offset 1}
               \label{fig:ks4ko1}
        \end{subfigure}
        \caption{Kernel size and kernel offset reconstruction comparison}
        \label{fig:ksko}
\end{figure}
\begin{figure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/DBBlur_ks-0_ko-0_2.png}
               \caption{Original reconstruction}
               \label{fig:kskdOrig2}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/DBBlur_ks-1_ko-1_2.png}
               \caption{kernel size 1, kernel offset 1}
               \label{fig:ks1ko12}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/DBBlur_ks-1_ko-2_2.png}
               \caption{kernel size 1, kernel offset 2}
               \label{fig:ks1ko22}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/DBBlur_ks-1_ko-4_2.png}
               \caption{kernel size 1, kernel offset 4}
               \label{fig:ks1ko42}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/DBBlur_ks-2_ko-1_2.png}
               \caption{kernel size 2, kernel offset 1}
               \label{fig:ks2ko12}
        \end{subfigure}        
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/DBBlur_ks-4_ko-1_2.png}
               \caption{kernel size 4, kernel offset 1}
               \label{fig:ks4ko12}
        \end{subfigure}
        \caption{Kernel size and kernel offset reconstruction comparison}
        \label{fig:ksko2}
\end{figure}

If the kernel size or a kernel offset is taken too large, the SDF values of MC vertices near to the bounds of the grid will be biased forming holes and artifacts on the surface (see Figures \ref{fig:ks4ko1} and \ref{fig:ks1ko4}). In general applying blur to the SDF tends to shrink the surface in the thin areas due imbalance of outer and inner MC vertices within fluid. The larger kernel size/offset the more shrinkage can be seen in the on the surface (see Figures \ref{fig:ks4ko12} and \ref{fig:ks1ko12}).
\subsection{Kernel depth}
The advantage of the static MC grid is that it has a static displacement of all grid vertices. This fact is exploited during for efficient computation of neighbors for each vertex of the MC grid. However, using the full neighborhood within the $kernelSize$ and $kernelOffset$ is not sufficient for level set blurring. As soon as the smoothing aims to remove bumps in the flat surface areas it is more practical to take into account level set vertices, that are in the neighborhood of the fluid surface. Thus, for each vertex of the level set gradient of the level set can be computed.
The gradient of the implicit function for the SDF is defined as
\begin{equation}
	\nabla\phi = \left( \dfrac{\partial\phi}{\partial x}, \dfrac{\partial\phi}{\partial y}, \dfrac{\partial\phi}{\partial z}\right)
\end{equation}
The gradient $\nabla\phi$ is perpendicular to the isocontours of $\phi$ and points in the
direction of increasing $\phi$. Therefore, if $x_0$ is a point on the zero isocontour
of $\phi$, i.e., a point on the fluid surface, then $\nabla\phi$ evaluated at $x_0$ is a vector that points in the same direction as the local unit (outward) normal N to the interface. Thus, the unit (outward) normal for points on the interface is \cite{LevelSetMethods}
\begin{equation}
	N = \dfrac{\nabla\phi}{|\nabla \phi|}
\end{equation}

For flat surface areas it is convenient to blur SDF vertex values w.r.t. vertices, which resides in a tangential direction to the surface normal.

\begin{figure}[H]
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/RealFluidSurfaceLevelSet.png}
               \caption{Expected reconstruction of flat surface}
               \label{fig:expected_fs}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/ReconstructedFluidSurface.png}
               \caption{Bumpy reconstruction of flat surface}
				\label{fig:recon_fs}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/LevelSetBlurFullKernel.png}
               \caption{Application of full kernel size}
               \label{fig:full_ks}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/LevelSetBlurKernelPart.png}
               \caption{Adjustment kernel in normal direction to iso-surface}
				\label{fig:partial_ks}
        \end{subfigure}

       \caption{Colored lines are iso-surface levels. Dots are MC grid vertices with their respective level set values}
       \label{fig:kd_surface_explenation}
 \end{figure}
At the Figure \ref{fig:expected_fs} expected iso-surface in flat fluid area is displayed. Dots of different colors are the MC grid vertices. Colors represent the level set value. In the perfect case level set ISO-lines (in the 2D example) forms straight lines, thus MC grid vertices along the iso-line will receive similar SDF evaluations. However, due to the irregular displacement of fluid particles surface is usually reconstructed as shown in Figure \ref{fig:recon_fs}. In case if we apply full kernel size (see Figure \ref{fig:full_ks}) we will pick level set values from different iso-surface levels, which will change level set values unpredictably.\\
The better approach is to pick a kernel frame so that only level set values of near-surface MC vertices will be used for blur operation (Figure \ref{fig:partial_ks}). This way blur operation will smooth out grid vertices along the iso lines. Especially the influence of the kernel depth can be seen in thin areas, where kernel frame is larger than a thickness of a fluid surface (see Figure \ref{fig:kd_influence example}).
\begin{figure}
        \begin{subfigure}[b]{0.9\textwidth}
               \includegraphics[width=\textwidth]{figures/KernelDepthOriginalReconstruction.png}
               \caption{Original ZhuBridson reconstruction}
               \label{fig:kd_original}
        \end{subfigure}
        \begin{subfigure}[b]{0.9\textwidth}
               \includegraphics[width=\textwidth]{figures/KernelDepth1.png}
               \caption{Blur with full kernel size}
				\label{fig:kd_full}
        \end{subfigure}
        \begin{subfigure}[b]{0.9\textwidth}
               \includegraphics[width=\textwidth]{figures/KernelDepth0_5.png}
               \caption{Blur with half kernel size}
               \label{fig:kd_half}
        \end{subfigure}

       \caption{Influence of the kernel depth on level set blurring}
       \label{fig:kd_influence example}
 \end{figure}
 \subsection{Neighbors detection algorithm}
In the Algorithm \ref{alg:blur_level_set} MC neighbor vertices are computed in function $getNeighbourVertices(vtx)$. The Algorithm \ref{alg:blur_nbs_search} describes the procedure of neighbors detection procedure.
\begin{algorithm}[H]
	\scriptsize
	\begin{algorithmic}
		\State $neighbors \gets \{vtx\}$
		\State $sdfGradient \gets \nabla_x sdf(vtx)$
		\If{$sdfGradient \cdot sdfGradient < 1e-6$}
			\State $return\ neighbors$
		\EndIf
		\State $Normalize sdfGradient$
		
		\For{$i \in [-kernelSize \cdot kernelOffset, kernelSize \cdot kernelOffset]$, $stepsize = kernelOffset$}
			\For{$j \in [-kernelSize \cdot kernelOffset, kernelSize \cdot kernelOffset]$, $stepsize = kernelOffset$}
				\For{$k \in [-kernelSize \cdot kernelOffset, kernelSize \cdot kernelOffset]$, $stepsize = kernelOffset$}
					\If{$i = 0 \land j = 0 \land k = 0$}
						\State $neighbors \gets neighbors \cup vtx$
						\State $continue$
					\EndIf
					
					\State $offsetVector \gets [i \cdot GridResolution, j \cdot GridResolution, k \cdot GridResolution]$;
					\If{$offsetVector \cdot sdfGradient \geq kernelDepth \cdot kernelSize \cdot GridResolution$}
						\State $continue$
					\EndIf
					
					\State $neighbors \gets neighbors \cup (vtx + offsetVector)$
				\EndFor
			\EndFor
		\EndFor
		\State $return\ neighbors$
	\end{algorithmic}
	\caption{neighborhood search for level set blur algorithm}
	\label{alg:blur_nbs_search}
\end{algorithm}
\textcolor{red}{TODO: add more explanations}
The algorithm traverses along all neighbor MC grid vertices within kernel size and kernel offset. It filters out a mesh vertices that are too fare from the reference vertex in a normal direction within a kernel depth. The normal is computed using a gradient of SDF in reference point. Well known forward differences are used to compute a gradient for the base vertex.
\begin{equation}
	\dfrac{\partial \phi}{\partial x} = \dfrac{\phi_{i+1} - \phi_i}{x_{i+1} - x_i}
\end{equation}
After computation of the gradient it is normalized, while only the unit normal is required. There is a degenerate case, when computed gradient vanishes. To handle this case computation of neighbors is imply skipped, and original SDF value is applied. After all, the probability of occurrence of such an event is too small. Figure \ref{fig:nghbrs_computation} shows the example of neighbors displacement with kernel size 3 and kernel depth 0.5.
\begin{figure}[H]
    \begin{subfigure}[b]{0.5\textwidth}
           \includegraphics[width=\textwidth]{figures/NeighborsComputation.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.5\textwidth}
           \includegraphics[width=\textwidth]{figures/NeighborsComputation2.png}
    \end{subfigure}

    \caption{resulting neighbors computed for one of the MC grid vertices (white points are computed neighbors)}
    \label{fig:nghbrs_computation}
\end{figure}

\section{Blur Iterations}
Apart to other parameters it was decided to check the influence of application of blur iteratively to the level set. In the Algorithm \ref{alg:blur_alg} blur applied iteratively on the level set. The results of the iterative blur can be observed on the Figure \ref{fig:bi_reconstruction}. The higher number of blur iterations the smother resulting surface becomes. 
\begin{figure}[H]
        \begin{subfigure}[b]{\textwidth}
               \includegraphics[width=\textwidth]{figures/ReconstructionIterations0.png}
				\caption{0 blur iterations}
               \label{fig:bi_original}
        \end{subfigure}
        \begin{subfigure}[b]{\textwidth}
               \includegraphics[width=\textwidth]{figures/ReconstructionIterations1.png}
				\caption{1 blur iterations}

				\label{fig:bi_1iteration}
        \end{subfigure}
       \caption{Investigation of blur iterations influence}
       \label{fig:bi_reconstruction1}

\end{figure}

\begin{figure}[H]

        \begin{subfigure}[b]{\textwidth}
               \includegraphics[width=\textwidth]{figures/ReconstructionIterations4.png}
				\caption{4 blur iterations}
               \label{fig:bi_4iteration}
        \end{subfigure}
        \begin{subfigure}[b]{\textwidth}
               \includegraphics[width=\textwidth]{figures/ReconstructionIterations8.png}
				\caption{8 blur iterations}
               \label{fig:bi_8iteration}
        \end{subfigure}
       \caption{Investigation of blur iterations influence}
       \label{fig:bi_reconstruction2}
\end{figure}
However, large amount of iterations smooths out level set to uniform value, thus on the Figure \ref{fig:bi_8iteration} holes can be seen. Figure \ref{fig:bi_levelset} displays the influence of blur iterations on level set itself. 
\begin{figure}[H]
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/LevelSetBlurIterations4.png}
				\caption{4 blur iterations}
               \label{fig:ls_bi_original}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
               \includegraphics[width=\textwidth]{figures/LevelSetBlurIterations16.png}
				\caption{16 blur iterations}

				\label{fig:ls_bi_16iteration}
        \end{subfigure}
       \caption{Level set depending on the number of blur iterations}
       \label{fig:bi_levelset}
\end{figure}

An important property of the blur reconstruction algorithm should be noted. Lets analyze the blur algorithm, applied on the level set (for simplicity 2D version will be analyzed).\\
Suppose matrix $A = 
\begin{pmatrix}
	1 & 1 & ... & 1\\
	1 & 1 & ... & 1\\
	. & . & ... & .\\
	1 & 1 & ... & 1\\
\end{pmatrix}$ is a $n \times n$ kernel where n is odd.
Kernel multiplication operation on level set element is described in equation \ref{eq:kernel-operation}
\begin{equation}
	\dfrac{1}{n^2}\cdot A\cdot sdf_{ij} = \sum_{k=- \left \lfloor{n/2}\right \rfloor}^{\left \lfloor{n/2}\right \rfloor}
		{\sum_{l=- \left \lfloor{n/2}\right \rfloor}^{\left \lfloor{n/2}\right \rfloor}{ A_{k+1, l+1} \cdot sdf_{i+k, j+l}}}
	\label{eq:kernel-operation}
\end{equation}
Suppose $n=3$ and $ sdf^{(k)}_{i,j} = \dfrac{1}{9} \cdot A \cdot sdf^{(k-1)}_{i,j} = \dfrac{1}{9^k} \cdot A^{(k)} \cdot sdf^{(0)}_{i,j}$\\. The claim is that $\dfrac{A^{(k)}}{9^k}$ satisfies properties of a kernel function:
\begin{itemize}
	\item positivity condition : $\forall a_{ij} \in A^(k): a_{ij} >= 0$
	\item normalization condition: $\forall a_{ij} \in A^(k), i,j \in [n]: \dfrac{\sum{a_{ij}}}{9^k} = 1$
	\item symmetry condition: $\forall i,j k=\left \lfloor{\dfrac{n}{2}}\right \rfloor $
\end{itemize}
Thus, when applied to the MC vertices plays a role of weights of the level set values in the neighborhood of the central vertice.\\
Proof of positivity condition:\\
As soon as each element of $A^{(k)}$ is formed by summing up neighboring elements of $A^{(k-1)}$ that is $a_{ij}^{(k)} = \sum_{k=-1}^{1}{\sum_{l=-1}^{1}{a^{(k-1)}_{i+k, j+l}}}$, then by simple induction starting with initial kernel $A^(1)=
\begin{pmatrix}
1 & 1 & 1\\
1 & 1 & 1\\
1 & 1 & 1\\
\end{pmatrix}$
it can be proven, that $a_{ij}^{(k)} >= a_{ij}^{(k-1)} >= a_{ij}^{(1)}$.\\
Proof of normalization condition: \\
Base step:\\ 
For initial matrix $A^{(1)}$ it is obvious that $\dfrac{\sum_{i,j = 1}^{n}{a_{ij}}}{9} = 1$.\\
Induction step: \\
Let $\dfrac{A^{(k)}}{9^k} = 1$. Taking into account, that $a_{ij}^{(k+1)} = \sum_{k=-1}^{1}{\sum_{l=-1}^{1}{a^{(k)}_{i+k, j+l}}}$ then $\forall a_{ij} \in A^{(k)}$ will appear in the sum of elements of $A^{(k+1)}$ exactly 9 times. Thus $\sum_{i,j}{a_{ij}^{(k+1)}} = 9 \cdot \sum_{i,j}{a_{ij}^{(k)}} = 9^{k+1}$\\
Some examples of a kernel functions iteratively formed from uniform kernel with kernel size = 1:\\
$A^2 = 
\begin{pmatrix}
1 & 2 & 3 & 2 & 1\\
2 & 4 & 6 & 4 & 2\\
3 & 6 & 9 & 6 & 3\\
2 & 4 & 6 & 4 & 2\\
1 & 2 & 3 & 2 & 1\\
\end{pmatrix}$
$A^3 = 
\begin{pmatrix}
 1 & 3 & 6 & 7 & 6 & 3 & 1\\
 3 & 9 & 18 & 21 & 18 & 9 & 3\\
 6 & 18 & 36 & 42 & 36 & 18 & 6\\
 7 & 21 & 42 & 49 & 42 & 21 & 7\\
 6 & 18 & 36 & 42 & 36 & 18 & 6\\
 3 & 9 & 18 & 21 & 18 & 9 & 3\\
 1 & 3 & 6 & 7 & 6 & 3 & 1\\
\end{pmatrix}$\\
$A^4 = 
\begin{pmatrix}
1 & 4 & 10 & 16 & 19 & 16 & 10 & 4 & 1\\
4 & 16 & 40 & 64 & 76 & 64 & 40 & 16 & 4\\
10 & 40 & 100 & 160 & 190 & 160 & 100 & 40 & 10\\
16 & 64 & 160 & 256 & 304 & 256 & 160 & 64 & 16\\
19 & 76 & 190 & 304 & 361 & 304 & 190 & 76 & 19\\
16 & 64 & 160 & 256 & 304 & 256 & 160 & 64 & 16\\
10 & 40 & 100 & 160 & 190 & 160 & 100 & 40 & 10\\
4 & 16 & 40 & 64 & 76 & 64 & 40 & 16 & 4\\
1 & 4 & 10 & 16 & 19 & 16 & 10 & 4 & 1\\
\end{pmatrix}$\\
This means, that given a kernel size = 1, kernel offset = 0 and blur iterations = n the final blur kernel applied will have a form of $ n \times n$ kernel that satisfies the kernel function conditions (proof for 3D case is similar for 2D case). Also the cost of the blur stage is reduced from $O(p \cdot n^2)$ when using $n \times n$ kernel to $O(9 \cdot p \cdot n)$ when using $3\times 3$ kernel applied n times on p MC grid cells. However, in  case of iterative approach kernel converges to Gaussian, in the latter case uniform kernel is applied. 


\section{Results and Performance comparison}
In this section performance of the blur algorithm will be analyzed w.r.t. the original reconstruction methods. All tests was performed on one core of AMD Ryzen 5. No parallelization was applied simplify the analysis. The analysis was performed for each stage described in \ref{alg:generateMesh} 
Table \ref{tab:perf_analysis} shows the wall-clock time for each method in different stages.
Reconstruction was performed on the simulation with 40000 particles, 93 frames and 0.02 particle radius, where:
\begin{conditions}
	DB & Density based Muller et.al. reconstruction (MC grid resolution: 0.020000)\\
	DBblur & Density based reconstruction Muller et.al. with level set blur (Kernel size: 2, Kernel offset: 1, Kernel depth: 0.5, Blur iterations: 1)\\
	ZB & Zhu and Bridson reconstruction (MC grid resolution: 0.020000, Support radius: 0.08\\
	ZBblur & Zhu and Bridson with level set blur (Smoothing factor: 1, Kernel size: 2, Kernel offset: 1, Kernel depth: 0.5, Blur iterations: 1)\\
\end{conditions}
\begin{table}[h]
	\begin{center}
		\scriptsize
		\begin{tabular}{|l|c|c|c|c|c|c|}
			\hline
			Simulation type & Muller et. al. & Blurred Muller et. al. & Zhu\&Bridson & ZBblur \\
			\hline
			Total execution time		&	250.210204	&	362.309801	&	227.907790	&	339.686174	\\
			Hash tables update			&	1.292020	&	1.491784	&	1.846468	&	2.009707	\\
			Detect surface particles	&	12.742551	&	12.753376	&	12.821589	&	12.805908	\\
			MC grid update				&	109.401044	&	108.327551	&	66.569929	&	68.213688	\\
			Level set update			&	113.503782	&	226.926150	&	125.736858	&	245.192591	\\
			Mesh generation				&	11.154644	&	10.985956	&	17.596987	&	9.521316	\\
			\hline
		\end{tabular}
	\end{center}
	\caption{Per stage performance analysis of original reconstruction methods versus level set blur}
	\label{tab:perf_analysis}
\end{table}

In Table \ref{tab:ks_perf_analysis} performance of the application is analyzed depending on the kernel size. Static simulation parameters:
\begin{conditions}
	\text{particle count}  & 40000\\
	\text{particle radius} & 0.02\\
	\text{smoothing factor} & 1.0\\
	\text{kernel offset} & 1\\
	\text{kernel size} & 1\\
	\text{kernel depth} & 1.0\\
	\text{blur iterations} & 1\\
\end{conditions}
\begin{table}[H]
	\begin{center}
		\scriptsize
		\begin{tabular}{|l|c|c|c|c|c|c|}
			\hline
			Kernel size & 1 & 2 & 3 & 4 \\
			\hline
			Hash tables update (sec)		&	0.036016	&	0.035996	&	0.036947	&	0.034786	\\
			Mesh generation	(sec)			&	0.154370	&	0.155268	&	0.154680	&	0.155067	\\
			Total execution time (sec)		&	4.661093	&	5.880080	&	8.681242	&	14.524655	\\
			MC grid update (sec)			&	1.350534	&	1.414452	&	1.378100	&	1.463115	\\
			Level set update (sec)			&	2.721548	&	3.873281	&	6.716356	&	12.471516	\\
			Detect surface particles(sec)	&	0.273974	&	0.274874	&	0.273340	&	0.276328	\\
			\hline
		\end{tabular}
	\end{center}
	\caption{Blurring method performance depending on kernel size}
	\label{tab:ks_perf_analysis}
\end{table}
From Table \ref{tab:ks_perf_analysis} it can be seen, that the runtime of the level set reconstruction rises in a factor of kernel size.\\

In Table \ref{tab:bi_perf_analysis} reconstruction runtime is given for the blur reconstruction depending on the blur iterations. 
\begin{table}[H]
	\begin{center}
		\scriptsize
		\begin{tabular}{|l|c|c|c|c|c|c|c|}
			\hline
			Blur iterations & 0 & 1 & 2 & 3 & 4 \\
			\hline
			Hash tables update (sec)		&	0.030858	&	0.037154	&	0.034373	&	0.035957	&	0.034917\\
			Mesh generation	(sec)			&	0.151087	&	0.154440	&	0.154813	&	 0.153584	&	0.153664\\
			Total execution time (sec)		&	4.007258	&	4.708030	&	5.272999	&	5.839118	&	6.475744\\
			MC grid update (sec)			&	1.435496	&	1.377351	&	1.393668	&	1.391468	&	1.443232\\
			Level set update (sec)			&	1.968029	&	2.715168	&	3.295140	&	3.859314	&	4.445282\\
			Detect surface particles(sec)	&	0.278672	&	0.280408	&	0.273828	&	0.276087	&	0.278408\\
			\hline
		\end{tabular}
	\end{center}
	\caption{Blur filter performance depending on blur iterations}
	\label{tab:bi_perf_analysis}
\end{table}
Runtime of the reconstruction depends linearly on the number of blur iterations.\\

Table \ref{tab:kd_perf_analysis} shows the performance of the application depending on the kernel depth value. Here kernel size is fixed to 5.
\begin{table}[H]
	\begin{center}
		\scriptsize
		\begin{tabular}{|l|c|c|c|c|}
			\hline
			Kernel depth & 0.1 & 0.25 & 0.5 & 1 \\
			\hline
			Hash tables update (sec)		&	0.035469	&	0.034264	&	0.035009	&	0.036902\\
			Mesh generation	(sec)			&	0.153513	&	0.153441	&	0.154675	&	 0.155028\\
			Total execution time (sec)		&	14.684650	&	16.564669	&	19.218910	&	24.861456\\
			MC grid update (sec)			&	1.427892	&	1.379971	&	1.413553	&	1.435164\\
			Level set update (sec)			&	12.667619	&	14.592833	&	17.217208	&	22.836116\\
			Detect surface particles(sec)	&	0.276308	&	0.281181	&	0.272071	&	0.276914\\
			\hline
		\end{tabular}
	\end{center}
	\caption{Blur filter performance depending on kernel depth}
	\label{tab:kd_perf_analysis}
\end{table}

Figure \ref{fig:DamBreak} and \ref{fig:DamBreak2} displays the  the comparison of reconstruction results between original and SDF blurred surface in Dam break scenario.
\begin{figure}
	\begin{center}
        \begin{subfigure}[b]{\textwidth}
               \includegraphics[width=\textwidth]{figures/ReconstructionDencityBased.png}
				\caption{DB}
        \end{subfigure}
        \begin{subfigure}[b]{\textwidth}
               \includegraphics[width=\textwidth]{figures/ReconstructionDencityBasedBlur.png}
				\caption{DBblur}
        \end{subfigure}
	\end{center}
	\caption{Fluid surface comparison in dam break scene (40000 SPH particles)}
	\label{fig:DamBreak}
\end{figure}
\begin{figure}
	\begin{center}
        \begin{subfigure}[b]{\textwidth}
               \includegraphics[width=\textwidth]{figures/ReconstructionZhuBridson.png}
				\caption{ZB}
        \end{subfigure}
        \begin{subfigure}[b]{\textwidth}
               \includegraphics[width=\textwidth]{figures/ReconstructionZhuBridsonBlur.png}
				\caption{ZBBlur}
        \end{subfigure}
	\end{center}
	\caption{Fluid surface comparison in dam break scene (40000 SPH particles)}
	\label{fig:DamBreak2}
\end{figure}

Another scene comparison is shown in the figure \ref{fig:MotorScene1} and \ref{fig:MotorScene2}.
\begin{figure}
	\begin{center}
        \begin{subfigure}[b]{1\textwidth}
               \includegraphics[width=\textwidth]{figures/ReconstructionMotorSceneDencityBased.png}
				\caption{Method: DB}
        \end{subfigure}
        \begin{subfigure}[b]{1\textwidth}
               \includegraphics[width=\textwidth]{figures/ReconstructionMotorSceneDencityBasedBlur.png}
				\caption{Method: DBblur}
        \end{subfigure}
        \caption{Motor scene fluid surface reconstruction comparison (5000 SPH particles)}
        \label{fig:MotorScene1}
	\end{center}
\end{figure}
 \begin{figure}
	\begin{center}
        \begin{subfigure}[b]{1\textwidth}
               \includegraphics[width=\textwidth]{figures/ReconstructionMotorSceneZhuBridson.png}
				\caption{Method: ZB}
        \end{subfigure}
       \begin{subfigure}[b]{1\textwidth}
               \includegraphics[width=\textwidth]{figures/ReconstructionMotorSceneZhuBridsonBlur.png}
				\caption{Method: ZBblur}
        \end{subfigure}
        \caption{Motor scene fluid surface reconstruction comparison (5000 SPH particles)}
        \label{fig:MotorScene2}
	\end{center}
\end{figure}
Figure \ref{fig:CrownScene1} \ref{fig:CrownScene2} and Table \ref{tab:CrownScene} shows the surface reconstruction comparison  and performance analysis for crown splash scene respectively. The blur filter was applied with kernel size: 1, kernel offset: 1, smoothing factor: 0.5. kernel depth: 0.5, blur iterations: 4.
\begin{figure}
	\begin{center}
        \begin{subfigure}[b]{\textwidth}
               \includegraphics[width=\textwidth]{figures/CrownOriginal.png}
				\caption{DB}
        \end{subfigure}
        \begin{subfigure}[b]{\textwidth}
               \includegraphics[width=\textwidth]{figures/CrownBlurred.png}
				\caption{DBblur}
        \end{subfigure}
	\end{center}
\end{figure}
\begin{figure}
	\begin{center}
       \begin{subfigure}[b]{\textwidth}
               \includegraphics[width=\textwidth]{figures/CrownOriginal2.png}
				\caption{DB}
        \end{subfigure}
        \begin{subfigure}[b]{\textwidth}
               \includegraphics[width=\textwidth]{figures/CrownBlurred2.png}
				\caption{DBblur}
        \end{subfigure}
        \caption{Crown splash scene with (60000 SPH particles)}
        \label{fig:CrownScene}
	\end{center}
\end{figure}
\begin{table}[H]
	\begin{center}
		\scriptsize
		\begin{tabular}{|l|c|c|c|c|}
			\hline
			Reconstruction method & DB & DBBlur\\
			\hline
			Hash tables update (sec)		&	0.080849	&	0.076910	\\
			Mesh generation	(sec)			&	0.631653	&	0.650907	\\
			Total execution time (sec)		&	9.749294	&	14.670331	\\
			MC grid update (sec)			&	2.037680	&	2.136541	\\
			Level set update (sec)			&	6.241172	&	11.109018	\\
			Detect surface particles(sec)	&	0.572956	&	0.565695	\\
			\hline
		\end{tabular}
	\end{center}
	\caption{Performance analysis of 2 frames reconstruction for crown splash scene}
	\label{tab:CrownScene}
\end{table}




\section{Conclusions}
After performing previously described experimentations with the developed method the conclusion can be made, that application of blur to the level set is definitely influences the final surface quality, and this method is able to smooth flat areas of surface, in the mean time saving small features in splash areas. The developed algorithm is applied on top of the original reconstruction algorithm. It can be applied to every reconstruction method, which uses scalar distance field to construct iso-surfaces and reconstruct the surface itself.\\ 
In the future efforts can be applied to improve algorithm performance, e.g. porting blur stage on GPU. The blur stage of the algorithm.\\
However, this method still has severe drawback - a problem of parametrization. There are multiple parameters that should be tunned, such as kernel size, kernel offset, kernel depth, smoothing factor, blur iterations. For different reconstruction methods, depending on the structure of the level set, simulation scale, performance and surface quality requirements, there is no golden middle for automatic application of the parametrization. Thus manual parameters tuning is required to achieve required reconstruction quality.\\
Two approach can be used to define a parametrization - fix kernel size = 1, kernel offset = 0, kernel depth = 1 and modify number of blur iterations and smoothing factor. In this case performance will be improved, but blur will not be flexible to the near surface areas, thus sharp features could be smoothed too much.\\
Another approach is to modify kernel size, kernel depth and smoothing factor, while keeping blur iterations fixed to 1. In this case most reconstruction method is more flexible to blurring low frequency bumps in flat surface areas saving most of the sharp features, meanwhile the performance of the reconstruction will be degraded.

